<!DOCTYPE html>
<html>
  <head>
		<title>traffic</title>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
      html { height: 100% }
      body { height: 70%; margin: 0; padding: 0 }
    </style>
		<link type="text/css" href="css/ui-lightness/jquery-ui-1.8.17.custom.css" rel="stylesheet" />
    <script type="text/javascript"
      src="http://maps.googleapis.com/maps/api/js?sensor=false">
    </script>
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/richmarker-compiled.js"></script>
		<script type="text/javascript" src="js/jquery-ui-1.8.17.custom.min.js"></script>
		<script type="text/javascript" src="js/jquery-ui-timepicker-addon.js"></script>
		<script type="text/javascript" src="js/buckets-minified.js"></script>
		<script type="text/javascript" src="common.js"></script>
    <script type="text/javascript">

var TEST_INVISIBLE = false;
var DISABLE_OVERTIME = false;
var SHOW_FRAMERATE = false;
var SHOW_TIME_SELECTOR = true;

var g_directions_service = new google.maps.DirectionsService();
var g_directions_result = null;
var g_selected_route_idx = -1;
var g_rendered_route_objects = new buckets.LinkedList();

function new_fudgeroute_data() {
	return {
		traffic_mofr2speed: new buckets.Dictionary(), 
		traffic_linedefs: new buckets.LinkedList(), 
		traffic_lines: new buckets.LinkedList(), 
		time_to_vid_to_vi: new buckets.Dictionary(), // key: date/time string.  value: dictionary (key: vid string, value: VehicleInfo object) 
		vid_to_static_vehicle_marker: new buckets.Dictionary(), 
		vid_to_heading_to_moving_vehicle_marker: new buckets.Dictionary(), 
		start_latlng: null, end_latlng: null,
		traffic_request_pending: false, 
		vehicles_request_pending: false
	};
}

var g_framerate_period_times = new buckets.LinkedList();
for(var i=0; i<15; i++) {
	g_framerate_period_times.add(0);
}
var g_framerate_last_epochtime = (new Date()).getTime();

var g_fudgeroute_data = new buckets.Dictionary();
var g_origmark=null, g_destmark=null;
var g_play_timer = null;
/* current time location (index into g_times) of the animation. */
var g_cur_minute_idx = 0;
/* Contains date/time strings.  Each element is a minute. */
var g_times = new buckets.LinkedList();
var g_refresh_data_from_server_timer = null;
var g_hidden_vids = new buckets.Set();
var g_playing = true;

var g_mouseover_infowin = null;
var g_mouseover_infowin_timer = null;

var HEADING_ROUNDING_DEGREES = 5;
var REFRESH_INTERVAL_MS = 15*1000;
var MOVING_VEHICLES_OVERTIME_FLASH_INTERVAL_MS = 500;
var MOVING_VEHICLES_ANIM_INTERVAL_MS = 100;
var MOFR_STEP = parseInt(get_sync('MOFR_STEP'), 10);
var CONFIGROUTE_TO_FUDGEROUTE = callpy_sync('routes.get_configroute_to_fudgeroute_map');

var g_zoom_to_vehicle_size = [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 13, 15, 25, 40, 50, 60, 70, 80, 100, 130, 100, ];

function get_vehicle_size_by_zoom(zoom_) {
	if(0 <= zoom_ && zoom_ < g_zoom_to_vehicle_size.length) {
		return g_zoom_to_vehicle_size[zoom_];
	} else {
		return g_zoom_to_vehicle_size[g_zoom_to_vehicle_size.length];
	}
}

function get_vehicle_size() {
	return get_vehicle_size_by_zoom(g_map.getZoom());
}

function kmph_to_color(kmph_) {
	var r = kmph_to_color_ints(kmph_);
	return sprintf('rgb(%d,%d,%d)', r[0], r[1], r[2]);
}

function kmph_to_color_ints(kmph_) {
	if(kmph_==null) {
		return [255, 255, 255];
	}
	var red = [150, 0, 0], yellow = [250, 250, 0], green = [0, 255, 0];
	var red_kmph = 5, yellow_kmph = 15, green_kmph = 25;
	if(kmph_ <= red_kmph) {
		return [0, 0, 0];
	} else if(red_kmph < kmph_ && kmph_ <= yellow_kmph) {
		return interp_color(red, yellow, (kmph_ - red_kmph)/(yellow_kmph - red_kmph));
	} else if(yellow_kmph < kmph_ && kmph_ <= green_kmph) {
		return interp_color(yellow, green, (kmph_ - yellow_kmph)/(green_kmph - yellow_kmph));
	} else {
		return green;
	}
}

function interp_color(c1_, c2_, percent_) {
	var r = [0, 0, 0];
	for(var i in r) {
		r[i] = get_range_val(0, c1_[i], 1.0, c2_[i], percent_);
	}
	return r;
}

function refresh_traffic_from_server(fudgeroute_) {
	var data = g_fudgeroute_data.get(fudgeroute_);
	if(!data.traffic_request_pending) {
		data.traffic_request_pending = true;
		callpy('traffic.get_traffics_dirfromlatlngs', fudgeroute_, data.start_latlng, data.end_latlng, true, get_datetime_from_gui(), 
			{success: function(r_) {
				if(!g_fudgeroute_data.containsKey(fudgeroute_)) {
					return;
				}
				data.traffic_request_pending = false;
				data.traffic_linedefs = to_buckets_list(r_[0]);
				data.traffic_mofr2speed = to_buckets_dict(r_[1]);
				update_last_updated_time();
				remake_traffic_lines_singleroute(fudgeroute_);
			}, 
			error: function() {
				data.traffic_request_pending = false;
			}}
		);
	}
}

function refresh_vehicles_from_server(fudgeroute_) {
	var data = g_fudgeroute_data.get(fudgeroute_);
	if(!data.vehicles_request_pending) {
		data.vehicles_request_pending = true;
		callpy('traffic.get_recent_vehicle_locations_dirfromlatlngs', fudgeroute_, data.start_latlng, data.end_latlng, true, get_datetime_from_gui(), 
			{success: function(r_) {
				if(!g_fudgeroute_data.containsKey(fudgeroute_)) {
					return;
				}
				data.vehicles_request_pending = false;
				forget_vehicles(fudgeroute_);
				update_last_updated_time();
				appropriate_vehicle_locations(fudgeroute_, r_);
				$('#playpause_button').prop('disabled', false);
				remake_static_vehicles_singleroute(fudgeroute_);
				remake_moving_vehicles_singleroute(fudgeroute_);
				refresh_vid_checkboxes_html();
				if(g_cur_minute_idx >= g_times.size()) { // want to keep animation going smoothly if possible - but if for some reason 
						// (what reason I don't know) the server returned fewer timeslices on this refresh and thus g_times shrunk, 
						// then here we handle that.  Not worth it to fuss about overtime here. 
					g_cur_minute_idx = 0;
				}
				update_time_display();
				show_cur_minute_vehicles_singleroute(fudgeroute_);
			}, 
			error: function() {
				data.vehicles_request_pending = false;
			}}
		);
	}
}

function refresh_vid_checkboxes_html() {
	var html = 'Showing vehicle IDs:<br>';
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		html += fudgeroute+': ';
		var vids = buckets_set_to_list(all_vids_singleroute(fudgeroute));
		sort_buckets_list(vids);
		vids.forEach(function(vid) {
			html += sprintf('%s <span onclick="%s" ondblclick="set_solo_vid(%s)">%s</span>&nbsp;&nbsp;', 
				make_vid_checkbox_html(fudgeroute, vid), 
				"$('#"+vid_checkbox_id(fudgeroute, vid)+"').trigger('click')", 
				vid, vid);
		});
		html += '<br>';
	});
	set_contents('p_vid_checkboxes', html);
}

function make_vid_checkbox_html(fudgeroute_, vid_) {
	return sprintf('<input type="checkbox" id="'+vid_checkbox_id(fudgeroute_, vid_)+'" onclick="on_vid_checkbox_clicked(\''+vid_+'\')" %s/>', 
			(g_hidden_vids.contains(vid_) ? '' : 'checked="checked"'));
}

function vid_checkbox_id(fudgeroute_, vid_) {
	return 'vid-checkbox-'+fudgeroute_+'-'+vid_;
}

function on_vid_checkbox_clicked(vid_) {
	if(g_hidden_vids.contains(vid_)) {
		g_hidden_vids.remove(vid_);
	} else {
		g_hidden_vids.add(vid_);
	}

	refresh_vid_checkboxes_selectedness();

	show_cur_minute_vehicles_allroutes();
}

function refresh_vid_checkboxes_selectedness() {
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		var vids = all_vids_singleroute(fudgeroute);
		vids.forEach(function(vid) {
			var checkbox_domid = vid_checkbox_id(fudgeroute, vid);
			set_selected(checkbox_domid, !g_hidden_vids.contains(vid));
		});
	});
}

function all_vids_allroutes() {
	var r = new buckets.Set();
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		add_all(r, all_vids_singleroute(fudgeroute));
	});
	return r;
}

function all_vids_singleroute(fudgeroute_) {
	var r = new buckets.Set();
	g_fudgeroute_data.get(fudgeroute_).time_to_vid_to_vi.forEach(function(time, vid_to_vi) {
		vid_to_vi.forEach(function(vid, vi) {
			r.add(vid);
		});
	});
	return r;
}

function get_moving_vehicle_marker_for_cur_minute(vid_) {
	var real_cur_minute = Math.min(g_cur_minute_idx, g_times.size()-1); // 'real' as in 'ignoring overtime' 
	var vi = g_minute_to_vid_to_vi[real_cur_minute].get(vid_);
	if(vi!=undefined) {
		return g_vid_to_heading_to_moving_vehicle_marker.get(vid_).get(round_heading(vi.heading));
	} else {
		return null;
	}
}

function svg_square(color_) {
	return sprintf('<svg width="20" height="20" version="1.1">' +
			'<polygon points="0,0 19,0 19,19, 0,19" fill="%s" fill-opacity="1" stroke="rgb(100,100,100)" stroke-width="0.5" />' + 
			'</svg>', color_);
}

function appropriate_vehicle_locations(fudgeroute_, raw_) {
	var data = g_fudgeroute_data.get(fudgeroute_);
	data.time_to_vid_to_vi.clear();
	for(var minute in raw_) {
		var timeslice = raw_[minute];
		var timestr = timeslice.shift();
		var vid_to_vi = new buckets.Dictionary();
		data.time_to_vid_to_vi.set(timestr, vid_to_vi);
		for(var timeslicei in timeslice) {
			var vi = timeslice[timeslicei];
			vid_to_vi.set(vi.vehicle_id, vi);
		}
	}

	update_g_times();
}

// make g_times the intersection of all times present in all routes. 
function update_g_times() {
	var new_times_set = null;
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		if(data.time_to_vid_to_vi.size() > 0) {
			if(new_times_set==null) {
				new_times_set = array_to_set(data.time_to_vid_to_vi.keys());
			} else {
				var oldsize = new_times_set.size();
				if(data.time_to_vid_to_vi.size() > 0) { // don't let empty ones influence this.  presumably we haven't 
						// received any data from the server yet for routes with an empty one of these. 
					new_times_set.intersection(array_to_set(data.time_to_vid_to_vi.keys()));
				}
				var newsize = new_times_set.size();
			}
		}
	});
	if(new_times_set == null) {
		new_times_set = new buckets.Set();
	}

	// Go through some contortions to turn new_times_set into a sorted list: 
	var new_times_sortedtree = new buckets.BSTree();
	new_times_set.forEach(function(e) {
		new_times_sortedtree.add(e);
	});
	g_times = new buckets.LinkedList();
	new_times_sortedtree.forEach(function(e) {
		g_times.add(e);
	});
}

function array_to_set(a_) {
	var r = new buckets.Set();
	for(var i in a_) {
		r.add(a_[i]);
	}
	return r;
}

function remake_moving_vehicles_allroutes(fudgeroute_) {
	g_fudgeroute_data.forEach(function(fudgeroute, data)  {
		remake_moving_vehicles_singleroute(fudgeroute);
	});
}

function remake_moving_vehicles_singleroute(fudgeroute_) {
	var data = g_fudgeroute_data.get(fudgeroute_);
	var new_vid_to_heading_to_moving_vehicle_marker = new buckets.Dictionary();
	data.time_to_vid_to_vi.forEach(function(timestr, vid_to_vi) {
		vid_to_vi.forEach(function(vid, vi) {
			var heading_to_moving_vehicle_marker = new_vid_to_heading_to_moving_vehicle_marker.get(vid);
			if(heading_to_moving_vehicle_marker == undefined) {
				heading_to_moving_vehicle_marker = new buckets.Dictionary();
				new_vid_to_heading_to_moving_vehicle_marker.set(vid, heading_to_moving_vehicle_marker);
			}
			var rounded_heading = round_heading(vi.heading);
			if(!heading_to_moving_vehicle_marker.containsKey(rounded_heading)) {
				var marker = make_vehicle_marker(vid, rounded_heading, 43, 79, false);
				heading_to_moving_vehicle_marker.set(rounded_heading, marker);
			}
		});
	});
	data.vid_to_heading_to_moving_vehicle_marker = new_vid_to_heading_to_moving_vehicle_marker;
}

function round_heading(heading_) {
	return round(heading_, HEADING_ROUNDING_DEGREES);
}

function update_last_updated_time() {
	var d = new Date();
	set_contents('p_last_updated', sprintf('(Last updated at %02d:%02d:%02d)', d.getHours(), d.getMinutes(), d.getSeconds()));
}

function refresh_data_from_server_timer_func() {
	refresh_traffic_and_vehicles_from_server_allroutes();
	schedule_refresh_data_from_server();
}

function refresh_traffic_and_vehicles_from_server_allroutes() {
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		refresh_traffic_from_server(fudgeroute);
		refresh_vehicles_from_server(fudgeroute);
	});
}

function remake_static_vehicles_allroutes() {
	g_fudgeroute_data.forEach(function(fudgeroute, data)  {
		remake_static_vehicles_singleroute(fudgeroute);
	});
}

function remake_static_vehicles_singleroute(fudgeroute_) {
	if(g_times.size() > 0) {
		var last_time = g_times.elementAtIndex(g_times.size()-1);
		var data = g_fudgeroute_data.get(fudgeroute_);
		data.time_to_vid_to_vi.get(last_time).forEach(function(vid, vi) {
			var marker = make_vehicle_marker(vid, vi.heading, vi.lat, vi.lon, true);
			data.vid_to_static_vehicle_marker.set(vid, marker);
		});
	}
}

function moving_vehicles_timer_func() {
	var method_start_epochtime = (new Date()).getTime();

	var timeout = (g_cur_minute_idx >= g_times.size()-1 
			? MOVING_VEHICLES_OVERTIME_FLASH_INTERVAL_MS : MOVING_VEHICLES_ANIM_INTERVAL_MS);
	if(DISABLE_OVERTIME) {
		timeout = MOVING_VEHICLES_ANIM_INTERVAL_MS;
	}
	g_play_timer = setTimeout('moving_vehicles_timer_func()', timeout);

	if(!g_playing) {
		return;
	}

	g_cur_minute_idx = (g_cur_minute_idx + 1) % (g_times.size() + 4);
	if(DISABLE_OVERTIME) {
		g_cur_minute_idx = g_cur_minute_idx % g_times.size();
	}
	update_time_display();
	move_vehicles_forward_one_minute();

	if(SHOW_FRAMERATE) {
		var cur_epochtime = (new Date()).getTime();
		if(g_cur_minute_idx > 0 && g_cur_minute_idx <= g_times.size()-2) {
			var cur_period_time = cur_epochtime - g_framerate_last_epochtime;

			var our_work_time = (cur_epochtime - method_start_epochtime);
			set_contents('p_worktime', sprintf('Our work time: %d ms', our_work_time));

			g_framerate_period_times.add(cur_period_time);
			g_framerate_period_times.removeElementAtIndex(0);
			var tally_time = 0;
			g_framerate_period_times.forEach(function(e) {
				tally_time += e;
			});
			var avg_millis_per_frame = tally_time/g_framerate_period_times.size();
			var frames_per_sec = 1000/avg_millis_per_frame;
			set_contents('p_framerate', sprintf('%.1f frames per second', frames_per_sec));
		}
		g_framerate_last_epochtime = cur_epochtime;
	}
}

function in_overtime() {
	return (g_cur_minute_idx >= g_times.size());
}

function in_overtime_flash_on() {
	return ((g_cur_minute_idx - g_times.size()) % 2 == 1);
}

function set_all_static_vehicle_markers_visible_allroutes(visible_) {
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		set_all_static_vehicle_markers_visible_singleroute(fudgeroute, visible_);
	});
}

// Not 'all' really.  This function respects the currently selected directions route, and the hidden vid checkboxes. 
function set_all_static_vehicle_markers_visible_singleroute(fudgeroute_, visible_) {
	var data = g_fudgeroute_data.get(fudgeroute_);
	data.vid_to_static_vehicle_marker.forEach(function(vid, marker) {
		marker.setVisible(visible_ && !g_hidden_vids.contains(vid));
	});
}

function move_vehicles_forward_one_minute() {
	if(g_cur_minute_idx < g_times.size()-1) {
		move_vehicles_forward_one_minute_normal();
	} else {
		move_vehicles_forward_one_minute_overtime();
	}
}

function move_vehicles_forward_one_minute_overtime() {
	if(g_cur_minute_idx == g_times.size()-1) {
		g_fudgeroute_data.forEach(function(fudgeroute, data) {
			if(data.time_to_vid_to_vi.size() > 0) {
				var prev_minute_vid_to_vi = data.time_to_vid_to_vi.get(g_times.elementAtIndex(g_times.size()-2));
				prev_minute_vid_to_vi.forEach(function(vid, prev_minute_vi) {
					var prev_heading = round_heading(prev_minute_vi.heading);
					if(!TEST_INVISIBLE) data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(prev_heading).setVisible(false);
				});
			}
		});
	} else {
		g_fudgeroute_data.forEach(function(fudgeroute, data) {
			if(data.time_to_vid_to_vi.size() > 0) {
				var last_time = g_times.elementAtIndex(g_times.size()-1);
				data.time_to_vid_to_vi.get(last_time).forEach(function(vid, vi) {
					var heading = round_heading(vi.heading);
					var marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(heading);
					if(g_cur_minute_idx == g_times.size()) {
						marker.setPosition(new google.maps.LatLng(vi.lat, vi.lon));
					}
					if(!TEST_INVISIBLE) marker.setVisible(!in_overtime_flash_on() && !g_hidden_vids.contains(vid));
				});
			}
		});
		set_all_static_vehicle_markers_visible_allroutes(in_overtime_flash_on());
	} 
}

function move_vehicles_forward_one_minute_normal() {
	var prev_minute_idx = g_cur_minute_idx-1;
	if(prev_minute_idx < 0) {
		prev_minute_idx = g_times.size()-1;
	}
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		if(data.time_to_vid_to_vi.size() > 0) {
			var prev_minute_vid_to_vi = data.time_to_vid_to_vi.get(g_times.elementAtIndex(prev_minute_idx));
			var cur_minute_vid_to_vi = data.time_to_vid_to_vi.get(g_times.elementAtIndex(g_cur_minute_idx));
			cur_minute_vid_to_vi.forEach(function(vid, cur_minute_vi) {
				if(g_hidden_vids.contains(vid)) {
					return;
				}
				var cur_within_bounds = within_map_bounds(cur_minute_vi);
				var prev_minute_vi = prev_minute_vid_to_vi.get(vid);
				var cur_heading = round_heading(cur_minute_vi.heading);
				if(prev_minute_vi == undefined) {
					if(cur_within_bounds) {
						var marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(cur_heading);
						marker.setPosition(new google.maps.LatLng(cur_minute_vi.lat, cur_minute_vi.lon));
						if(!TEST_INVISIBLE)  marker.setVisible(true);
					}
				} else {
					var prev_within_bounds = within_map_bounds(prev_minute_vi);
					var prev_heading = round_heading(prev_minute_vi.heading);
					if(cur_heading == prev_heading) {
						if((prev_within_bounds && cur_within_bounds) || (!prev_within_bounds && cur_within_bounds)) {
							var marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(cur_heading);
							marker.setPosition(new google.maps.LatLng(cur_minute_vi.lat, cur_minute_vi.lon));
							marker.setVisible(true);
						} else if(prev_within_bounds && !cur_within_bounds) {
							var marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(cur_heading);
							marker.setVisible(false);
						} 
					} else {
						if(prev_within_bounds && cur_within_bounds) {
							var prev_marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(prev_heading);
							var cur_marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(cur_heading);
							prev_marker.setVisible(false);
							cur_marker.setPosition(new google.maps.LatLng(cur_minute_vi.lat, cur_minute_vi.lon));
							cur_marker.setVisible(true);
						} else if(prev_within_bounds && !cur_within_bounds) {
							var prev_marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(prev_heading);
							prev_marker.setVisible(false);
						} else if(!prev_within_bounds && cur_within_bounds) {
							var cur_marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(cur_heading);
							cur_marker.setPosition(new google.maps.LatLng(cur_minute_vi.lat, cur_minute_vi.lon));
							cur_marker.setVisible(true);
						}
						//var cur_marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(cur_heading);
						//cur_marker.setPosition(new google.maps.LatLng(cur_minute_vi.lat, cur_minute_vi.lon));
						//if(!TEST_INVISIBLE) cur_marker.setVisible(true);
						//var prev_marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(prev_heading);
						//if(!TEST_INVISIBLE) prev_marker.setVisible(false);
					}
				}
			});
			prev_minute_vid_to_vi.forEach(function(vid, prev_minute_vi) {
				if(!cur_minute_vid_to_vi.containsKey(vid) || g_hidden_vids.contains(vid)) {
					var prev_within_bounds = within_map_bounds(prev_minute_vi);
					var prev_heading = round_heading(prev_minute_vi.heading);
					if(prev_within_bounds) {
						if(!TEST_INVISIBLE) data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(prev_heading).setVisible(false);
					}
				}
			});
		}
	});
}

function within_map_bounds(vi_) {
	var map_bounds = g_map.getBounds();
	var sw = map_bounds.getSouthWest(), ne = map_bounds.getNorthEast();
	return (sw.lat() <= vi_.lat && vi_.lat <= ne.lat()) && (sw.lng() <= vi_.lon && vi_.lon <= ne.lng());
}

function update_time_display() {
	if(g_times.size() > 0) {
		var timestr = g_times.elementAtIndex(Math.min(g_cur_minute_idx, g_times.size()-1));
		set_analog_clock_timestr(timestr);
		var cur_time_html = timestr.substr(0, 16);
		if((g_cur_minute_idx == g_times.size()-1) || (in_overtime() && in_overtime_flash_on())) {
			cur_time_html = '<b>'+cur_time_html+'</b>';
		}
		set_contents('p_cur_time', cur_time_html);
	} else {
		set_analog_clock_hour_minute(0, 0);
		set_contents('p_cur_time', ' ');
	}

}

function set_analog_clock_timestr(timestr_) {
	// We want a timestamp in the format: 2012-10-30 01:14:00 
	assert((new RegExp('\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}')).test(timestr_), "date/time does not match");

	var hour = parseInt(timestr_.substr(11, 2), 10), minute = parseInt(timestr_.substr(14, 2), 10);
	set_analog_clock_hour_minute(hour, minute);
}

// SVG clock from https://gist.github.com/1188550 
function set_analog_clock_hour_minute(hour_, minute_) {
	var hourangle = ((hour_ % 12) + minute_/60)*30;
	var minangle = minute_*6;

	// Get SVG elements for the hands of the clock
	//var sechand = document.getElementById('secondhand');
	var minhand = document.getElementById("minutehand");
	var hourhand = document.getElementById("hourhand");

	// Set an SVG attribute on them to move them around the clock face
	//sechand.setAttribute("transform", "rotate(" + secangle + ",50,50)");
	minhand.setAttribute("transform", "rotate(" + minangle + ",50,50)");
	hourhand.setAttribute("transform", "rotate(" + hourangle + ",50,50)");
}

function make_vehicle_marker(vid_, heading_, lat_, lon_, static_aot_moving_) {
	var color = vid_to_color(vid_);
	var size = get_vehicle_size();
	var marker = new google.maps.Marker({
			position: new google.maps.LatLng(lat_, lon_),
			map: g_map,
			draggable: false,
			icon: new google.maps.MarkerImage(cgi_url('get_vehicle_image.cgi', [size, heading_, color, (static_aot_moving_ ? 0.8 : 0.3)]), 
					null, null, new google.maps.Point(size/2, size/2)),
			visible: false
		});
	if(!TEST_INVISIBLE) marker.setVisible(true);
	add_vid_mouseover_infowin(marker, size, vid_);
	add_solo_vid_click_listener(marker, vid_);
	return marker;
}

function add_solo_vid_click_listener(vehicle_marker_, vid_) {
	google.maps.event.addListener(vehicle_marker_, 'click', function() { set_solo_vid(vid_); });
}

function set_solo_vid(vid_) {
	if(is_solo_already()) {
		g_fudgeroute_data.forEach(function(fudgeroute, data) {
			data.time_to_vid_to_vi.forEach(function(time, vid_to_vi) {
				vid_to_vi.forEach(function(vid, vi) {
					var checkbox = document.getElementById(vid_checkbox_id(fudgeroute, vid));
					if(!checkbox.checked) {
						checkbox.checked = true;
						on_vid_checkbox_clicked(vid);
					}
				});
			});
		});
	} else {
		g_fudgeroute_data.forEach(function(fudgeroute, data) {
			data.time_to_vid_to_vi.forEach(function(time, vid_to_vi) {
				vid_to_vi.forEach(function(vid, vi) {
					var checkbox = document.getElementById(vid_checkbox_id(fudgeroute, vid));
					if(vid == vid_) {
						if(!checkbox.checked) {
							checkbox.checked = true;
							on_vid_checkbox_clicked(vid);
						}
					} else {
						if(checkbox.checked) {
							checkbox.checked = false;
							on_vid_checkbox_clicked(vid);
						}
					}
				});
			});
		});
	}
}

function is_solo_already() {
	return (all_vids_allroutes().size() == g_hidden_vids.size()+1);
}

function add_vid_mouseover_infowin(vehicle_marker_, vehicle_marker_size_, vid_) {
	add_mouseover_infowin(vehicle_marker_, vehicle_marker_size_/3, 'Vehicle ID: '+vid_);
}

function add_mouseover_infowin(map_object_, offset_, text_) {
	google.maps.event.addListener(map_object_, 'mouseover', function() {
		clear_mouseover_infowin();
		if(g_mouseover_infowin_timer != null) {
			clearTimeout(g_mouseover_infowin_timer);
			g_mouseover_infowin_timer = null;
		}
		var pos = null;
		if(map_object_ instanceof google.maps.Marker) {
			pos = map_object_.getPosition();
		} else if(map_object_ instanceof google.maps.Polyline) {
			pos = map_object_.getPath().getAt(0);
		} else {
			assert(false, "add_mouseover_infowin unknown object type");
		}
		g_mouseover_infowin = new google.maps.InfoWindow({content: text_, disableAutoPan: true, 
				position: pos, pixelOffset: new google.maps.Size(offset_, -offset_) 
			});
		g_mouseover_infowin.open(g_map);
	});
	google.maps.event.addListener(map_object_, 'mouseout', function() {
		g_mouseover_infowin_timer = setTimeout('clear_mouseover_infowin()', 1000);
	});
}

function clear_mouseover_infowin() {
	if(g_mouseover_infowin != null) {
		g_mouseover_infowin.close();
		g_mouseover_infowin = null;
	}
}

function forget_vehicles_allroutes() {
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		forget_vehicles(fudgeroute);
	});
}

function forget_vehicles(fudgeroute_) {
	forget_moving_vehicles(fudgeroute_);
	forget_static_vehicles(fudgeroute_);
}

function forget_moving_vehicles(fudgeroute_) {
	if(g_fudgeroute_data.containsKey(fudgeroute_)) {
		var m = g_fudgeroute_data.get(fudgeroute_).vid_to_heading_to_moving_vehicle_marker;
		m.forEach(function(vid, heading_to_moving_vehicle_marker) {
			hide_vehicles(heading_to_moving_vehicle_marker.values());
		});
		m.clear();
	}
}

function forget_static_vehicles(fudgeroute_) {
	if(g_fudgeroute_data.containsKey(fudgeroute_)) {
		var m = g_fudgeroute_data.get(fudgeroute_).vid_to_static_vehicle_marker;
		hide_vehicles(m.values());
		m.clear();
	}
}

function hide_vehicles(list_) {
	for(var i in list_) {
		var m = list_[i];
		m.setMap(null);
	}
}

function redraw_vehicle_markers() {
	forget_vehicles_allroutes();
	remake_static_vehicles_allroutes();
	remake_moving_vehicles_allroutes();
	show_cur_minute_vehicles_allroutes();
}

function remake_traffic_lines_allroutes() {
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		remake_traffic_lines_singleroute(fudgeroute);
	});
}

function remake_traffic_lines_singleroute(fudgeroute_) {
	forget_traffic_lines(fudgeroute_);

	var data = g_fudgeroute_data.get(fudgeroute_);
	if(data != undefined) {
		data.traffic_linedefs.forEach(function(linedef) {
			var traf = data.traffic_mofr2speed.get(linedef.mofr);
			var new_lines = make_traffic_line(linedef.start_latlon, linedef.end_latlon, (traf!=null ? traf.kmph : null), linedef.mofr, true);
			add_all(data.traffic_lines, new_lines);
		});
	}
}

function is_fudgeroute_part_of_selected_directions_route(fudgeroute_) {
	assert(false);
	if(0 <= g_selected_route_idx && g_selected_route_idx < g_directions_result.routes.length) {
		var legs = g_directions_result.routes[g_selected_route_idx].legs;
		for(var legi in legs) {
			var leg = legs[legi];
			for(var stepi in leg.steps) {
				var step = leg.steps[stepi];
				var line = null;
				if(step.travel_mode == google.maps.TravelMode.TRANSIT) {
					var step_transitline_shortname = step.transit.line.short_name;
					var step_fudgeroute = CONFIGROUTE_TO_FUDGEROUTE[step_transitline_shortname];
					if(step_fudgeroute == fudgeroute_) {
						return true;
					}
				}
			}
		}
	}
	return false;
}

function forget_traffic_lines(fudgeroute_) {
	var data = g_fudgeroute_data.get(fudgeroute_);
	if(data != undefined) {
		data.traffic_lines.forEach(function(e) {
			e.setMap(null);
		});
		data.traffic_lines.clear();
	}
}

function traffic_lines_set_visible(fudgeroute_, visible_) {
	var data = g_fudgeroute_data.get(fudgeroute_);
	if(data != undefined) {
		data.traffic_lines.forEach(function(e) {
			e.setVisible(visible_);
		});
	}
}

function add_text_to_marker(marker_, string_) {
	var text_marker = new RichMarker({
		position: marker_.getPosition(),
		map: g_map,
		draggable: false,
		flat: true,
		anchor: new google.maps.Size(-40, -60), 
		content: sprintf('<svg width="120px" height="25px" version="1.1">' +
				'<text x="0" y="20" font-size="20" stroke="rgb(0,0,0)" stroke-width="0.3" fill="rgb(255,124,112)">%s</text>' +
				'</svg>', string_)
		});
	google.maps.event.addListener(marker_, 'position_changed', function() {
		text_marker.setPosition(marker_.getPosition());
	});
}

function initialize() {

	init_datetimepicker();
	if(!SHOW_TIME_SELECTOR) {
		$('#div_time_selector').remove();
	}

	init_map();
	google.maps.event.addListener(g_map, 'zoom_changed', function() {
		remake_traffic_lines_allroutes();
		redraw_vehicle_markers();
	});
	var origlat, origlon, destlat, destlon;
	if(false) { // true for dundas 
		var westlat = 43.65078;
		var westlon = -79.4138099;
		var eastlat = 43.6523999;
		var eastlon = -79.40589;
		if(false) { // true for eastbound 
			origlat=westlat; origlon=westlon; destlat=eastlat; destlon=eastlon;
		} else {
			destlat=westlat; destlon=westlon; origlat=eastlat; origlon=eastlon;
		}
	} else { 
		if(true) { // true for north on bathurst 
			origlat=43.64457; origlon=-79.4165499; destlat=43.65454560588453; destlon=-79.40695567330022;
		} else if(true) { // true for eastbound 
			origlat=43.64457; origlon=-79.4165499; destlat=43.6471199; destlon=-79.4042;
		} else {
			destlat=43.64457; destlon=-79.4165499; origlat=43.6471199; origlon=-79.4042;
		}
	}
	g_origmark = new google.maps.Marker({
		position: new google.maps.LatLng(origlat, origlon),
		map: g_map,
		draggable: true
		});
	add_text_to_marker(g_origmark, "Starting point");

	google.maps.event.addListener(g_origmark, 'dragend', function() { on_trip_mark_moved(); });

	g_destmark = new google.maps.Marker({
		position: new google.maps.LatLng(destlat, destlon),
		map: g_map,
		draggable: true
		});
	add_text_to_marker(g_destmark, "Destination");
	google.maps.event.addListener(g_destmark, 'dragend', function() { on_trip_mark_moved(); });

	//draw_all_routes();

	set_play_buttons_appropriately();

	g_play_timer = setTimeout('moving_vehicles_timer_func()', 0);

	get_google_directions();

	if(!SHOW_FRAMERATE) {
		$('#div_framerate').remove();
	}

}

function set_play_buttons_appropriately() {
	$('#playpause_button').prop('value', (g_playing ? 'Pause' : 'Play'));
	$('#back_button').prop('disabled', g_playing);
	$('#forward_button').prop('disabled', g_playing);
}

function on_playpause_clicked() {
	g_playing = !g_playing;
	set_play_buttons_appropriately();
	if(g_playing) { // go from paused to playing: 
		schedule_refresh_data_from_server();
	} else { // go from playing to paused: 
		stop_refresh_data_from_server_timer();
		if(g_times.size() > 0) {
			if(g_cur_minute_idx > g_times.size()-1) {
				g_cur_minute_idx = g_times.size()-1;
			}
			show_cur_minute_vehicles_allroutes();
			update_time_display();
		}
	}
}

function show_cur_minute_vehicles_allroutes() {
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		show_cur_minute_vehicles_singleroute(fudgeroute);
	});
}

function show_cur_minute_vehicles_singleroute(fudgeroute_) {
	set_all_static_vehicle_markers_visible_singleroute(fudgeroute_, true);

	var data = g_fudgeroute_data.get(fudgeroute_);
	data.vid_to_heading_to_moving_vehicle_marker.forEach(function(vid, heading_to_marker) {
		heading_to_marker.forEach(function(heading, marker) {
			if(!TEST_INVISIBLE) marker.setVisible(false);
		});
	});
	var vid_to_vi = data.time_to_vid_to_vi.get(g_times.elementAtIndex(g_cur_minute_idx));
	if(vid_to_vi != undefined) {
		vid_to_vi.forEach(function(vid, vi) {
			if(!g_hidden_vids.contains(vid)) {
				var marker = data.vid_to_heading_to_moving_vehicle_marker.get(vid).get(round_heading(vi.heading));
				marker.setPosition(google_LatLng([vi.lat, vi.lon]));
				if(!TEST_INVISIBLE) marker.setVisible(true);
			}
		});
	}
}

function on_forward_clicked() {
	if(g_times.size() == 0) {
		return;
	}
	g_cur_minute_idx = Math.min(g_cur_minute_idx+1, g_times.size()-1);
	update_time_display();
	show_cur_minute_vehicles_allroutes();
}

function on_back_clicked() {
	if(g_times.size() == 0) {
		return;
	}
	g_cur_minute_idx = Math.max(g_cur_minute_idx-1, 0);
	update_time_display();
	show_cur_minute_vehicles_allroutes();
}

function is_traffictype_current() {
	return (radio_val('traffictype') == 'current');
}

function is_traffictype_historical() {
	return !is_traffictype_current();
}

function init_datetimepicker() {
	set_value('datetimepicker_textfield', get_sync('datetime.txt'));
	$('#datetimepicker_textfield').datetimepicker({
		dateFormat: 'yy-mm-dd', 
		onSelect: function(dateText, inst) { 
			on_datetime_changed();
		}
	});
	update_datetimepicker_enabledness();
}

function on_traffictype_changed() {
	update_datetimepicker_enabledness();
	stop_refresh_data_from_server_timer();
	forget_data_allroutes();
	update_g_times();
	get_google_directions();
	if(is_traffictype_current()) {
		schedule_refresh_data_from_server();
	}
}

function schedule_refresh_data_from_server() {
	g_refresh_data_from_server_timer = setTimeout('refresh_data_from_server_timer_func()', REFRESH_INTERVAL_MS);
}

function update_datetimepicker_enabledness() {
	$('#datetimepicker_textfield').prop('disabled', is_traffictype_current());
}

function substr_int(str_, startidx_, len_) {
	return parseInt(str_.substr(startidx_, len_), 10);
}

function get_date_from_gui() {
	var d = get_datetime_from_gui();
	if(d == 0) {
		return new Date();
	} else {
		return new Date(substr_int(d, 0, 4), substr_int(d, 5, 2)-1, substr_int(d, 8, 2), substr_int(d, 11, 2), substr_int(d, 14, 2), 0, 0);
	}
}

// Returns either 0 (an integer) or a string (in yyyy-MM-dd HH:MM format).   Our server functions can handle both. 
function get_datetime_from_gui() {
	if(SHOW_TIME_SELECTOR) {
		return (is_traffictype_current() ? 0 : get_value('datetimepicker_textfield'));
	} else {
		return 0;
	}
}

function draw_all_routes() {
	callpy('routes.get_all_routes_latlons', 
			function(r_) {
				draw_routes(r_);
			});
}

function draw_routes(routes_) {
	for(var i=0; i<routes_.length; i++) {
		var latlngs = new Array();
		for(var j=0; j<routes_[i].length; j++) {
			var pt = routes_[i][j];
			latlngs.push(new google.maps.LatLng(pt[0], pt[1]));
		}
		var polyline = new google.maps.Polyline({
			path: latlngs, 
			strokeWeight: 3, 
			strokeOpacity: 0.3, 
			strokeColor: 'rgb(50,50,50)', 
			zIndex: -10, 
			map: g_map
		});
	}
}

function stop_refresh_data_from_server_timer() {
	if(g_refresh_data_from_server_timer != null) {
		clearTimeout(g_refresh_data_from_server_timer);
		g_refresh_data_from_server_timer = null;
	}
}

function on_trip_mark_moved() {
	get_google_directions();
}

function get_google_directions() {
  var request = {origin: g_origmark.getPosition(), destination: g_destmark.getPosition(),
    travelMode: google.maps.DirectionsTravelMode.TRANSIT,
    provideRouteAlternatives: true,
    transitOptions: {departureTime: get_date_from_gui()} 
  };
	inc_loading_get_count();
	g_directions_service.route(request, function(response, status) {
		dec_loading_get_count();
		if(status == google.maps.DirectionsStatus.OK) {
			g_directions_result = response;
			//g_selected_route_idx = 0;
			//render_route(g_selected_route_idx);
			forget_data_allroutes();
			update_fudgeroutes_from_directions_result();
			refresh_traffic_and_vehicles_from_server_allroutes();
		} else {
			alert(sprintf('Could not get directions.  %s', status));
		}
	});
}

function forget_data_allroutes() {
	g_fudgeroute_data.forEach(function(fudgeroute, data) {
		data.traffic_lines.forEach(function(line) {
			line.setMap(null);
		});
		data.vid_to_static_vehicle_marker.forEach(function(vid, marker) {
			marker.setMap(null);
		});
		data.vid_to_heading_to_moving_vehicle_marker.forEach(function(vid, heading_to_moving_vehicle_marker) {
			heading_to_moving_vehicle_marker.forEach(function(heading, marker) {
				marker.setMap(null);
			});
		});
	});
	g_fudgeroute_data.clear();
}

function update_fudgeroutes_from_directions_result_test() {
	g_fudgeroute_data.clear();
	var routes = ['queen', 'spadina', 'bathurst', 'ossington', 'dufferin', 'lansdowne', 'king', 'dundas', 'college'];
	var dirlatlngs = [
		[[43.64678263020183, -79.40575404366155], [43.644608817203384, -79.41777034004826]], 
		[[43.650819502780166, -79.39734263619084], [43.65622227685813, -79.39991755684514]], 
		[[43.64833530560961, -79.40506739815373], [43.65392460475481, -79.4059257050385]], 
		[[43.6462857655947, -79.4194869538178], [43.65113002020209, -79.42137522896428]], 
		[[43.64684473798873, -79.4308166046967], [43.65193735798561, -79.43236155708928]], 
		[[43.64541624264291, -79.43862719734807], [43.64982583624162, -79.43965716560979]], 
		[[43.64081998366622, -79.4187144776215], [43.6390186511334, -79.42618174751897]], 
		[[43.651813152879164, -79.4085006256928], [43.65032267156586, -79.42068858345647]], 
		[[43.655787588878745, -79.41013140877385], [43.65435930621993, -79.42266268929143]]
		];
	for(var i in routes) {
		var route = routes[i];
		var start_latlng = dirlatlngs[i][0];
		var end_latlng = dirlatlngs[i][1];

		var new_data = new_fudgeroute_data();
		new_data.start_latlng = start_latlng;
		new_data.end_latlng = end_latlng;
		g_fudgeroute_data.set(route, new_data);
		break;
	}
}

function update_fudgeroutes_from_directions_result() {
	if(g_directions_result != null) {
		for(var routei in g_directions_result.routes) {
			var legs = g_directions_result.routes[routei].legs;
			for(var legi in legs) {
				var leg = legs[legi];
				for(var stepi in leg.steps) {
					var step = leg.steps[stepi];
					var line = null;
					if(step.travel_mode == google.maps.TravelMode.TRANSIT) {
						var step_transitline_shortname = step.transit.line.short_name;
						var step_fudgeroute = CONFIGROUTE_TO_FUDGEROUTE[step_transitline_shortname];
						if(step_fudgeroute != undefined && !g_fudgeroute_data.containsKey(step_fudgeroute)) {
							var new_data = new_fudgeroute_data();
							new_data.start_latlng = step.start_location;
							new_data.end_latlng = step.end_location;
							g_fudgeroute_data.set(step_fudgeroute, new_data);
						}
					}
				}
			}
		}
	}
	//update_fudgeroutes_from_directions_result_test();
}

function route_checkbox_id(idx_) {
	return 'route_checkbox_'+idx_;
}

function on_route_checkbox_clicked(idx_) {
	render_route(idx_);
}

function render_route(idx_) {
	clear_rendered_route_objects();
	if(!(0 <= idx_ && idx_ < g_directions_result.routes.length)) {
		return;
	}
	var legs = g_directions_result.routes[idx_].legs;
	for(var legi in legs) {
		var leg = legs[legi];
		for(var stepi in leg.steps) {
			var step = leg.steps[stepi];
			var line = null;
			if(step.travel_mode == google.maps.TravelMode.TRANSIT) {
				line = new google.maps.Polyline({path: step.path, strokeWeight: get_traffic_line_width()+2, strokeColor: 'rgb(134,133,247)', 
					strokeOpacity: 0.7, map: g_map});
			} else {
				line = new google.maps.Polyline({path: step.path, strokeWeight: 5, strokeColor: 'rgb(140,140,140)', 
					strokeOpacity: 0.7, map: g_map});
			}
			g_rendered_route_objects.add(line);
		}
	}
}

function clear_rendered_route_objects() {
	g_rendered_route_objects.forEach(function(e) {
		e.setMap(null);
	});
	g_rendered_route_objects.clear();
}

function on_datetime_changed() {
	on_traffictype_changed();
}

function get_est_trip_time() {
	var startmofr, endmofr;
	if(g_direction == 0) {
		startmofr = g_orig_mofr;
		endmofr = g_dest_mofr;
	} else {
		startmofr = g_dest_mofr;
		endmofr = g_orig_mofr;
	}
	var r_secs = 0;
	if(startmofr != round_up_off_step(startmofr, MOFR_STEP)) {
		var dist_m = round_up_off_step(startmofr, MOFR_STEP) - startmofr;
		var speed_kmph = get_traffic_kmph(round(startmofr, MOFR_STEP));
		if(speed_kmph == -1) {
			return -1;
		}
		var speed_mps = kmph_to_mps(speed_kmph);
		r_secs += dist_m/speed_mps;
	}
	var cur_offstep_mofr = round_up_off_step(startmofr, MOFR_STEP);
	while(cur_offstep_mofr < round_down_off_step(endmofr, MOFR_STEP)) {
		var mofr_with_ref_speed = round_up(cur_offstep_mofr, MOFR_STEP);
		var speed_kmph = get_traffic_kmph(mofr_with_ref_speed);
		if(speed_kmph == -1) {
			return -1;
		}
		var speed_mps = kmph_to_mps(speed_kmph);
		r_secs += MOFR_STEP/speed_mps;
		cur_offstep_mofr += MOFR_STEP;
	}
	if(endmofr != round_down_off_step(endmofr, MOFR_STEP)) {
		dist_m = endmofr - round_down_off_step(endmofr, MOFR_STEP);
		var speed_kmph = get_traffic_kmph(round(endmofr, MOFR_STEP));
		if(speed_kmph == -1) {
			return -1;
		}
		var speed_mps = kmph_to_mps(speed_kmph);
		r_secs += dist_m/speed_mps;
	}
	return r_secs/60;
}

// returns -1 if we have no traffic data for that mofr step. 
function get_traffic_kmph(mofr_) {
	if(mofr_ % MOFR_STEP != 0 || mofr_ < 0) {
		throw sprintf('Got %d.  We expect a multiple of %d.', mofr_, MOFR_STEP);
	}
	var traf = g_traffic_mofr2speed[mofr_];
	if(traf == undefined) {
		return -1;
	} else {
		return traf.kmph;
	}
}

function kmph_to_mps(kmph_) {
	return kmph_*1000.0/(60*60);
}

// 'off step' means 'steps shifted in phase by half the period, if you will'  
function round_up_off_step(x_, step_) {
	var r = round_down_off_step(x_, step_);
	return (r == x_ ? r : r+step_);
}

function round_down_off_step(x_, step_) {
	// assert type(x_) == int and type(step_) == int
	return Math.floor((x_-step_/2)/step_)*step_ + step_/2;
}

function round_up(x_, step_) {
	var r = round_down(x_, step_);
	return (r == x_ ? r : r+step_);
}

function round_down(x_, step_) {
	// assert type(x_) == int and type(step_) == int
	return (Math.floor(x_/step_)*step_);
}

function round(x_, step_) {
	var rd = round_down(x_, step_)
	var ru = round_up(x_, step_)
	return (x_ - rd < ru - x_ ? rd : ru);
}

function get_traffic_line_width() {
	return get_vehicle_size()/9;
}

// kmph_ == null ==> no data available. 
// return: Either one or two two-point Polylines.  second one, if present, will be a background line, for the purpose of outlining.
// 		both lines will have the same start- and end-position. 
function make_traffic_line(start_latlon_, end_latlon_, kmph_, mofr_, visible_) {
	var r = new buckets.LinkedList();
	var line = new google.maps.Polyline({
		path: [google_LatLng(start_latlon_), google_LatLng(end_latlon_)], 
		map: g_map, 
		strokeColor: kmph_to_color(kmph_), 
		strokeWeight: get_traffic_line_width(),  
		zIndex: -5,
		visible: visible_
	});
	r.add(line);
	if(kmph_==null) {  // draw additional grey line behind, to make the white stand out. 
		var line_behind = new google.maps.Polyline({
			path: [google_LatLng(start_latlon_), google_LatLng(end_latlon_)], 
			map: g_map, 
			strokeColor: 'rgb(150,150,150)', 
			strokeWeight: get_traffic_line_width()+1, 
			zIndex: -6, 
			visible: visible_
		});
		r.add(line_behind);
	}

	var infowin_text = sprintf("The average speed here, in this direction, is %s.", 
			(kmph_==null ? 'not available' : sprintf('%.1f kmph', kmph_)));
	add_mouseover_infowin(line, 0, infowin_text);

	return r;
}

var g_vehicle_colors = [
	//'rgb(0,0,0)', 
	'rgb(100,100,100)', 
	//'rgb(0,255,0)', 
	//'rgb(0,100,0)', 
//	'rgb(50,50,255)', 
//	'rgb(0,0,150)', 
//	'rgb(100,100,0)', 
//	'rgb(0,255,255)', 
//	'rgb(0,100,100)', 
//	'rgb(255,0,255)', 
//	'rgb(100,0,100)', 
];

function vid_to_color(vid_) {
	return g_vehicle_colors[hashCode(vid_) % g_vehicle_colors.length];
}


$(document).ready(initialize);

    </script>

		<!-- SVG clock from https://gist.github.com/1188550 --> 
    <style>
      /* These CSS styles all apply to the SVG elements defined below */
      #clock {
        /* styles for everything in the clock */
        stroke: black;
        /* black lines */
        stroke-linecap: round;
        /* with rounded ends */
        fill: #eef;
        /* on a light blue gray background */
      }
      #face { stroke-width: 3px;}
      /* clock face outline */
      #ticks { stroke-width: 2; }
      /* lines that mark each hour */
      #hourhand {stroke-width: 5px;}
      /* wide hour hand */
      #minutehand {stroke-width: 3px;} /* narrow minute hand */
      #secondhand {stroke-width: 1px;}
      #numbers {
        /* how to draw the numbers */
        font-family: sans-serif; font-size: 7pt; font-weight: bold;
        text-anchor: middle; stroke: none; fill: black;
      }
    </style>
  </head>
  <body>
		<div id="map_canvas" style="width:100%; height:100%"></div>
		<div>
			<div id="div_framerate">
				<br/><p id='p_framerate'/>
				<br/><p id='p_worktime'/>
			</div>
			<br/>
			<a href="instructions.html">Instructions.</a>
			<hr>
			<svg id="clock" viewBox="0 0 100 100" width="100" height="100">
				<!-- SVG clock from https://gist.github.com/1188550 --> 

				<circle id="face" cx="50" cy="50" r="45"/> <!-- the clock face -->

				<g id="ticks">
					<!-- 12 hour tick marks -->
					<line x1='50' y1='5.000' x2='50.00' y2='10.00'/>
					<line x1='72.50' y1='11.03' x2='70.00' y2='15.36'/>
					<line x1='88.97' y1='27.50' x2='84.64' y2='30.00'/>
					<line x1='95.00' y1='50.00' x2='90.00' y2='50.00'/>
					<line x1='88.97' y1='72.50' x2='84.64' y2='70.00'/>
					<line x1='72.50' y1='88.97' x2='70.00' y2='84.64'/>
					<line x1='50.00' y1='95.00' x2='50.00' y2='90.00'/>
					<line x1='27.50' y1='88.97' x2='30.00' y2='84.64'/>
					<line x1='11.03' y1='72.50' x2='15.36' y2='70.00'/>
					<line x1='5.000' y1='50.00' x2='10.00' y2='50.00'/>
					<line x1='11.03' y1='27.50' x2='15.36' y2='30.00'/>
					<line x1='27.50' y1='11.03' x2='30.00' y2='15.36'/>
				</g>

				<g id="numbers">
					<!-- Number the cardinal directions-->
					<text x="50" y="18">12</text><text x="85" y="53">3</text>
					<text x="50" y="88">6</text><text x="15" y="53">9</text>
				</g>

				<!-- Draw hands pointing straight up. We rotate them in the code. -->
				<g id="hands"> <!-- Add shadows to the hands -->
					<line id="hourhand" x1="50" y1="50" x2="50" y2="24"/>
					<line id="minutehand" x1="50" y1="50" x2="50" y2="20"/>
					<!--<line id="secondhand" x1="50" y1="50" x2="50" y2="16"/>-->
				</g>
			</svg> <br/>
			<span id="p_cur_time">&nbsp;</span><br/>
			<span id="p_last_updated"></span>
			<hr>
			Animated vehicles: 
			<input type="button" id="playpause_button" onclick="on_playpause_clicked()" value="" />
			<input type="button" id="back_button" onclick="on_back_clicked()" value="<" />
			<input type="button" id="forward_button" onclick="on_forward_clicked()" value=">" />
			<br/>
			<font size="-1">
			<p>Details:</p>
			<p id="p_vid_checkboxes">&nbsp;</p>
			<div id="div_time_selector">
			<input id="current_button" type="radio" name="traffictype" value="current"    onclick="on_traffictype_changed()"   checked="checked"   />Now
			<input id="historical_button" type="radio" name="traffictype" value="historical" onclick="on_traffictype_changed()"   />Past
			<input id="datetimepicker_textfield" type="text" name="datetimepicker_textfield" value="" />
			</div>
			</font>
			<hr>

			<p><a href="about.html">About this website.</a></p>
			<p></p>
		</div>
  </body>
</html>
